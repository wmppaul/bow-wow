import * as THREE from 'three';

/**
 * Export a Three.js mesh or group to STL format
 */
export function exportToSTL(object: THREE.Object3D, filename: string = 'boat-hull.stl'): void {
  // Collect all meshes
  const meshes: THREE.Mesh[] = [];
  object.traverse((child) => {
    if (child instanceof THREE.Mesh) {
      meshes.push(child);
    }
  });

  if (meshes.length === 0) {
    console.error('No meshes found to export');
    return;
  }

  // Generate STL content
  const stlContent = generateBinarySTL(meshes);

  // Download
  const blob = new Blob([stlContent], { type: 'application/octet-stream' });
  const url = URL.createObjectURL(blob);

  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/**
 * Generate binary STL data from meshes
 */
function generateBinarySTL(meshes: THREE.Mesh[]): ArrayBuffer {
  // Count total triangles
  let triangleCount = 0;
  for (const mesh of meshes) {
    const geometry = mesh.geometry;
    const index = geometry.getIndex();
    if (index) {
      triangleCount += index.count / 3;
    } else {
      const position = geometry.getAttribute('position');
      triangleCount += position.count / 3;
    }
  }

  // Binary STL format:
  // 80 bytes header
  // 4 bytes triangle count (uint32)
  // For each triangle:
  //   12 bytes normal (3 x float32)
  //   36 bytes vertices (3 x 3 x float32)
  //   2 bytes attribute byte count (uint16, usually 0)
  const bufferSize = 80 + 4 + triangleCount * 50;
  const buffer = new ArrayBuffer(bufferSize);
  const dataView = new DataView(buffer);

  // Header (80 bytes)
  const header = 'Boat Hull STL - Generated by Boat Hull Designer';
  for (let i = 0; i < 80; i++) {
    dataView.setUint8(i, i < header.length ? header.charCodeAt(i) : 0);
  }

  // Triangle count
  dataView.setUint32(80, triangleCount, true);

  let offset = 84;
  const normal = new THREE.Vector3();
  const v1 = new THREE.Vector3();
  const v2 = new THREE.Vector3();
  const v3 = new THREE.Vector3();
  const edge1 = new THREE.Vector3();
  const edge2 = new THREE.Vector3();

  for (const mesh of meshes) {
    const geometry = mesh.geometry;
    const position = geometry.getAttribute('position');
    const index = geometry.getIndex();

    // Apply mesh world matrix to vertices
    const worldMatrix = mesh.matrixWorld;

    const processTriangle = (i1: number, i2: number, i3: number) => {
      // Get vertices
      v1.fromBufferAttribute(position, i1).applyMatrix4(worldMatrix);
      v2.fromBufferAttribute(position, i2).applyMatrix4(worldMatrix);
      v3.fromBufferAttribute(position, i3).applyMatrix4(worldMatrix);

      // Calculate normal
      edge1.subVectors(v2, v1);
      edge2.subVectors(v3, v1);
      normal.crossVectors(edge1, edge2).normalize();

      // Write normal
      dataView.setFloat32(offset, normal.x, true); offset += 4;
      dataView.setFloat32(offset, normal.y, true); offset += 4;
      dataView.setFloat32(offset, normal.z, true); offset += 4;

      // Write vertices
      dataView.setFloat32(offset, v1.x, true); offset += 4;
      dataView.setFloat32(offset, v1.y, true); offset += 4;
      dataView.setFloat32(offset, v1.z, true); offset += 4;

      dataView.setFloat32(offset, v2.x, true); offset += 4;
      dataView.setFloat32(offset, v2.y, true); offset += 4;
      dataView.setFloat32(offset, v2.z, true); offset += 4;

      dataView.setFloat32(offset, v3.x, true); offset += 4;
      dataView.setFloat32(offset, v3.y, true); offset += 4;
      dataView.setFloat32(offset, v3.z, true); offset += 4;

      // Attribute byte count
      dataView.setUint16(offset, 0, true); offset += 2;
    };

    if (index) {
      for (let i = 0; i < index.count; i += 3) {
        processTriangle(index.array[i], index.array[i + 1], index.array[i + 2]);
      }
    } else {
      for (let i = 0; i < position.count; i += 3) {
        processTriangle(i, i + 1, i + 2);
      }
    }
  }

  return buffer;
}

/**
 * Alternative: Generate ASCII STL (larger file but human-readable)
 */
export function generateAsciiSTL(meshes: THREE.Mesh[]): string {
  let stl = 'solid boat_hull\n';

  const normal = new THREE.Vector3();
  const v1 = new THREE.Vector3();
  const v2 = new THREE.Vector3();
  const v3 = new THREE.Vector3();
  const edge1 = new THREE.Vector3();
  const edge2 = new THREE.Vector3();

  for (const mesh of meshes) {
    const geometry = mesh.geometry;
    const position = geometry.getAttribute('position');
    const index = geometry.getIndex();
    const worldMatrix = mesh.matrixWorld;

    const addTriangle = (i1: number, i2: number, i3: number) => {
      v1.fromBufferAttribute(position, i1).applyMatrix4(worldMatrix);
      v2.fromBufferAttribute(position, i2).applyMatrix4(worldMatrix);
      v3.fromBufferAttribute(position, i3).applyMatrix4(worldMatrix);

      edge1.subVectors(v2, v1);
      edge2.subVectors(v3, v1);
      normal.crossVectors(edge1, edge2).normalize();

      stl += `  facet normal ${normal.x} ${normal.y} ${normal.z}\n`;
      stl += '    outer loop\n';
      stl += `      vertex ${v1.x} ${v1.y} ${v1.z}\n`;
      stl += `      vertex ${v2.x} ${v2.y} ${v2.z}\n`;
      stl += `      vertex ${v3.x} ${v3.y} ${v3.z}\n`;
      stl += '    endloop\n';
      stl += '  endfacet\n';
    };

    if (index) {
      for (let i = 0; i < index.count; i += 3) {
        addTriangle(index.array[i], index.array[i + 1], index.array[i + 2]);
      }
    } else {
      for (let i = 0; i < position.count; i += 3) {
        addTriangle(i, i + 1, i + 2);
      }
    }
  }

  stl += 'endsolid boat_hull\n';
  return stl;
}
